{"version":3,"file":"readme-box.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["import { request } from '@octokit/request'\n\nexport interface ReadmeBoxOpts {\n  owner: string\n  repo: string\n  token: string\n  branch?: string\n}\n\nexport interface UpdateSectionOpts extends ReadmeBoxOpts {\n  section: string\n  message?: string\n}\n\nexport interface ReplaceSectionOpts {\n  section: string\n  newContents: string\n  oldContents: string\n}\n\nexport class ReadmeBox {\n  public owner: string\n  public repo: string\n  public token: string\n  public branch: string\n  private request: typeof request\n\n  constructor(opts: ReadmeBoxOpts) {\n    this.owner = opts.owner\n    this.repo = opts.repo\n    this.token = opts.token\n    this.branch = opts.branch || 'master'\n\n    this.request = request.defaults({\n      headers: {\n        authorization: `token ${this.token}`\n      }\n    })\n  }\n\n  static async updateSection(newContents: string, opts: UpdateSectionOpts) {\n    const box = new ReadmeBox(opts)\n\n    // Get the README\n    const { content, sha, path } = await box.getReadme()\n\n    // Replace the old contents with the new\n    const replaced = box.replaceSection({\n      section: opts.section,\n      oldContents: content,\n      newContents\n    })\n\n    // Actually update the README\n    return box.updateReadme({\n      content: replaced,\n      message: opts.message,\n      branch: opts.branch,\n      sha,\n      path\n    })\n  }\n\n  async getReadme() {\n    const { data } = await this.request('GET /repos/:owner/:repo/readme', {\n      owner: this.owner,\n      repo: this.repo,\n      ref: this.branch\n    })\n\n    // The API returns the blob as base64 encoded, we need to decode it\n    const encoded = data.content\n    const decoded = Buffer.from(encoded, 'base64').toString('utf8')\n\n    return {\n      content: decoded,\n      sha: data.sha,\n      path: data.path\n    }\n  }\n\n  async updateReadme(opts: {\n    content: string\n    sha: string\n    path?: string\n    message?: string\n    branch?: string\n  }) {\n    return this.request('PUT /repos/:owner/:repo/contents/:path', {\n      owner: this.owner,\n      repo: this.repo,\n      content: Buffer.from(opts.content).toString('base64'),\n      path: opts.path || 'README.md',\n      message: opts.message || 'Updating the README!',\n      sha: opts.sha,\n      branch: opts.branch || 'master'\n    })\n  }\n\n  getSection(section: string, content: string) {\n    const { regex } = this.createRegExp(section)\n    const match = content.match(regex)\n    return match?.groups?.content\n  }\n\n  replaceSection(opts: ReplaceSectionOpts) {\n    const { regex, start, end } = this.createRegExp(opts.section)\n\n    if (!regex.test(opts.oldContents)) {\n      throw new Error(\n        `Contents do not contain start/end comments for section \"${opts.section}\"`\n      )\n    }\n\n    const newContentsWithComments = `${start}\\n${opts.newContents}\\n${end}`\n    return opts.oldContents.replace(regex, newContentsWithComments)\n  }\n\n  private createRegExp(section: string) {\n    const start = `<!--START_SECTION:${section}-->`\n    const end = `<!--END_SECTION:${section}-->`\n    const regex = new RegExp(`${start}\\n(?:(?<content>[\\\\s\\\\S]+)\\n)?${end}`)\n    return { regex, start, end }\n  }\n}\n"],"names":["opts","owner","repo","token","branch","request","defaults","headers","authorization","this","updateSection","newContents","box","ReadmeBox","getReadme","sha","path","replaced","replaceSection","section","oldContents","content","updateReadme","message","ref","data","Buffer","from","toString","getSection","createRegExp","match","regex","groups","_match$groups","start","end","test","Error","replace","RegExp"],"mappings":"8IA2BcA,QACLC,MAAQD,EAAKC,WACbC,KAAOF,EAAKE,UACZC,MAAQH,EAAKG,WACbC,OAASJ,EAAKI,QAAU,cAExBC,QAAUA,UAAQC,SAAS,CAC9BC,QAAS,CACPC,uBAAwBC,KAAKN,WAKtBO,uBAAcC,EAAqBX,WACxCY,EAAM,IAAIC,EAAUb,0BAGWY,EAAIE,mCAAxBC,IAAAA,IAAKC,IAAAA,KAGhBC,EAAWL,EAAIM,eAAe,CAClCC,QAASnB,EAAKmB,QACdC,cALMC,QAMNV,YAAAA,WAIKC,EAAIU,aAAa,CACtBD,QAASJ,EACTM,QAASvB,EAAKuB,QACdnB,OAAQJ,EAAKI,OACbW,IAAAA,EACAC,KAAAA,sEAIEF,gDACmBL,KAAKJ,QAAQ,iCAAkC,CACpEJ,MADqBQ,KACTR,MACZC,KAFqBO,KAEVP,KACXsB,IAHqBf,KAGXL,gCAHJqB,IAAAA,WAUD,CACLJ,QAHcK,OAAOC,KADPF,EAAKJ,QACgB,UAAUO,SAAS,QAItDb,IAAKU,EAAKV,IACVC,KAAMS,EAAKT,+CAITM,sBAAatB,8BAOVS,KAAKJ,QAAQ,yCAA0C,CAC5DJ,MADKQ,KACOR,MACZC,KAFKO,KAEMP,KACXmB,QAASK,OAAOC,KAAK3B,EAAKqB,SAASO,SAAS,UAC5CZ,KAAMhB,EAAKgB,MAAQ,YACnBO,QAASvB,EAAKuB,SAAW,uBACzBR,IAAKf,EAAKe,IACVX,OAAQJ,EAAKI,QAAU,kDAI3ByB,WAAA,SAAWV,EAAiBE,WACRZ,KAAKqB,aAAaX,GAC9BY,EAAQV,EAAQU,QADdC,cAEDD,MAAAA,aAAAA,EAAOE,2BAAPC,EAAeb,WAGxBH,eAAA,SAAelB,SACiBS,KAAKqB,aAAa9B,EAAKmB,SAA7Ca,IAAAA,MAAOG,IAAAA,MAAOC,IAAAA,QAEjBJ,EAAMK,KAAKrC,EAAKoB,mBACb,IAAIkB,iEACmDtC,EAAKmB,oBAK7DnB,EAAKoB,YAAYmB,QAAQP,EADGG,OAAUnC,EAAKW,iBAAgByB,MAI5DN,aAAA,SAAaX,OACbgB,0BAA6BhB,WAC7BiB,wBAAyBjB,iBAExB,CAAEa,MADK,IAAIQ,OAAUL,mCAAsCC,GAClDD,MAAAA,EAAOC,IAAAA"}